/* Generated by CodeDescriptor 1.5.0.0907 */
/*
* Project Name      -> Error Handling
* Version           -> 1.0.0.0528
* Author            -> Hm @ Workstadion.: QP-01-02
* Build Date        -> 28.05.2018 06:38:46
* Description       -> Description
*
*	Aufbau des Fehlerspeichers.:
*
*	*->buff[ID][NUM] -> ID = Fehler Typ (I2C , USART , LCD usw.).
*						NUM = Fehler die Aufgetreten sind ( Anzahl der zu speichernden -
*							  Fehler hängt von "ERROR_BUFFER_ID_SIZE" ab.
*
*
*	Bevor die Funktionen genutzt werden, muss einmal "errorInit( FEHLERSTRUKTUR )" aufgerufen werden!
*
*	Fehler werden mithilfe der Funktion "errorWrite( FEHLERSTRUKTUR , FEHLER_ID , ERROR ) in den Fehlerspeicher eingetragen.
*
*	Die Funktion "*errorGetExist( FEHLERSTRUKTUR )" liefert einen String mit den im Fehlerspeicher vorhandenen Fehlern & dazugehörigen ID´s
*
*/


#define ERROR_BUFFER_ID_OVERFLOW	1
#define ERROR_BUFFER_NUM_OVERFLOW	2

#define	ERROR_BUFFER_ID_SIZE		10
#define ERROR_BUFFER_NUM_SIZE		4

#include <stdint.h>

typedef struct
{
	/*
	*	Fehlerspeicher
	*/
	uint8_t buff[ERROR_BUFFER_ID_SIZE][ERROR_BUFFER_NUM_SIZE];
	
	/*
	*	Welche Art von Fehler ist aufgetreten?!
	*	
	*	z.B.: UART , LCD , I2C usw.
	*/
	uint8_t id;
	
	/*
	*	Zähler für aufgetretene Fehler
	*/
	uint8_t err[ERROR_BUFFER_ID_SIZE][1];
	
}error_t;


enum
{
	_ERROR_I2C_				= 0x00, // I2C Fehler! Nicht ändern.
	ERROR_I2C_NO_ACK		= 0x01,
	ERROR_I2C_ADDRESS_TX	= 0x02,
	ERROR_I2C_BYTE_TX		= 0x03,	
};



uint8_t errorInit( error_t *strc );

uint8_t errorFreeSize( error_t *strc , uint8_t id );

void errorClear( error_t *strc , uint8_t id );

uint8_t errorWrite( error_t *strc , uint8_t id , uint8_t err );

uint8_t errorWriteCircular( error_t *strc , uint8_t id , uint8_t err );

char *errorGetExist( error_t *strc );

char *errorGetById( error_t * strc , uint8_t id );
