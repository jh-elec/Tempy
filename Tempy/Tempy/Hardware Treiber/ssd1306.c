/* Generated by CodeDescriptor 1.5.0.0907 */
/*
* Project Name      -> SSD1306 GLCD Driver
* Version           -> 1.0.0.0414
* Author            -> Jan Homann @ Workstadion.: XXXJANIIIX3XXX
* Build Date        -> 14.04.2018 09:13:07
* Description       -> Treiber unterstützt das I2C Protokoll.
*
*
*
*/

#include <avr/io.h>
#include <avr/interrupt.h>
#include <string.h>
#include <stdlib.h>
#include "I2C.h"
#include "ssd1306.h"

static uint8_t DisplayRam[ ( SSD1306_LCD_Width * SSD1306_LCD_HEIGHT ) / 8 ] = "0xFF";

uint8_t buff[3]			= "";
uint8_t ssd1306Error	= 0;

uint8_t errTmp			= 0;
uint8_t ssd1306ErrCnt[ALL_ERRORS];

static const uint8_t __flash *_ptrFont = NULL;



static uint8_t Ssd1306Write( uint8_t *buff , uint16_t leng )
{
	cli();
	
	if ( i2c_start( SSD1306_ADDR + I2C_WRITE ) )
	{
		ssd1306Error |= ( 1 << START_NOT_RDY );
		ssd1306ErrCnt[START_NOT_RDY]++;
		i2c_stop();
		sei();
		return 1;
	}

	for ( uint16_t i = 0 ; i < leng ; i++ )
	{
		if ( leng == 1 )
		{
			errTmp = i2c_write( *buff );
			if ( errTmp )
			{
				errTmp = 0;
				ssd1306Error |= ( 1 << TX_BYTE );
				ssd1306ErrCnt[TX_BYTE]++;
			}
			
			i2c_stop();
			sei();
			
			return 0;
		}
		else
		{
			errTmp = i2c_write( *buff++ );
			if ( errTmp )
			{
				errTmp = 0;
				ssd1306Error |= ( 1 << TX_BYTE );
				ssd1306ErrCnt[TX_BYTE]++;
			}
		}
	}
	i2c_stop();

	sei();
	
	return 0;
}

static inline uint8_t swapBits(uint8_t byte)
{
	uint8_t ret = 0;
	
	for ( uint8_t i = 0 ; i < 8 ; i++ )
	{
		ret >>= 1;
		ret |= byte & 0x80;
		byte <<= 1;
	}
	return ret;
}

void Ssd1306SendCmd(uint8_t c)
{
	buff[0] = SSD1306_MODE_CMD;
	buff[1] = c;
	
	Ssd1306Write( buff , 2 );
}

void Ssd1306SendData( uint8_t data )
{
	buff[0] = SSD1306_MODE_DATA;
	buff[1] = data;
	
	Ssd1306Write( buff , 2 );
}

void Ssd1306Init(void)
{
	static uint8_t buff[] =
	{
		0xAE,			// Display OFF (sleep mode)
		0x20, 
	
		0b00,			// Set Memory Addressing Mode
						// 00=Horizontal Addressing Mode; 01=Vertical Addressing Mode;
						// 10=Page Addressing Mode (RESET); 11=Invalid
						
		0xB0,			// Set Page Start Address for Page Addressing Mode, 0-7
		0xC8,			// Set COM Output Scan Direction
		0x00,			// --set low column address
		0x10,			// --set high column address
		0x40,			// --set start line address
		0x81, 255,		// Set contrast control register
		0xA1,			// Set Segment Re-map. A0=address mapped; A1=address 127 mapped.
		0xA6,			// Set display mode. A6=Normal; A7=Inverse
		0xA8, 0x3F,		// Set multiplex ratio(1 to 64)
		0xA4,			// Output RAM to Display
						// 0xA4=Output follows RAM content; 0xA5,Output ignores RAM content
		0xD3, 0x00,		// Set display offset. 00 = no offset
		0xD5,			// --set display clock divide ratio/oscillator frequency
		0xF0,			// --set divide ratio
		0xD9, 0,		// Set pre-charge period
		0xDA, 0x12,		// Set com pins hardware configuration
		0xDB,			// --set vcomh
		0x20,			// 0x20,0.77xVcc
		0x8D, 0x04,		// Set DC-DC enable
		0xAF,			// Display ON in normal mode
	};

	for (uint8_t i = 0 ; i < sizeof(buff) ; i++ )
	{
		Ssd1306SendCmd( buff[i] );
	}
	
	Ssd1306ClearScreen();
}

void Ssd1306Goto( uint8_t y , uint8_t x )
{
	Ssd1306SendCmd( SSD1306_MODE_CMD );	
	Ssd1306SendCmd( SSD1306_CMD_PAGE_START_ADDR + y );
	Ssd1306SendCmd( ( ( x & 0xF0) >> 4 ) | 0x10 );
	Ssd1306SendCmd( x & 0x0F );
}

void Ssd1306SetFont( const uint8_t __flash *ptrFnt )
{
	_ptrFont = ptrFnt;
}

uint8_t GetFontHeight( const uint8_t __flash *ptrFont )	
{
	return ptrFont[ _FONT_HEIGHT ];
}

Font_t GetFont( uint8_t c )
{
	Font_t Font;
	
	Font.uiWidht			= 0;
	Font.uiHeight			= GetFontHeight( _ptrFont );
	Font.uiHeightInBytes	= ( Font.uiHeight + 7 ) / 8; 

	uint8_t uiFirstChar = _ptrFont[ _FONT_FIRST_CHAR ];
	uint8_t uiCharCount = _ptrFont[ _FONT_CHAR_COUNT ];
	
	c -= uiFirstChar;

	if ( IsFixedWidthFont( _ptrFont ) ) 
	{
		Font.uiWidht = _ptrFont[ _FONT_FIXED_WIDTH ];
		Font.uiIndex = ( c * Font.uiHeightInBytes * Font.uiWidht + _FONT_WIDTH_TABLE );
	}else 
	{
		/*
		* Because there is no table for the offset of where the data
		* for each character glyph starts, run the table and add up all the
		* widths of all the characters prior to the character we
		* need to locate.
		*/
		for (uint8_t i = 0; i < c; i++) 
		{
			Font.uiIndex += _ptrFont[ _FONT_WIDTH_TABLE + i ];
		}
		/*
		* Calculate the offset of where the font data
		* for our character starts.
		* The index value from above has to be adjusted because
		* there is potentialy more than 1 byte per column in the glyph,
		* when the characgter is taller than 8 bits.
		* To account for this, index has to be multiplied
		* by the height in bytes because there is one byte of font
		* data for each vertical 8 pixels.
		* The index is then adjusted to skip over the font width data
		* and the font header information.
		*/
		Font.uiIndex = ( Font.uiIndex * Font.uiHeightInBytes + uiCharCount + _FONT_WIDTH_TABLE );

		/*
		* Finally, fetch the width of our character
		*/
		Font.uiWidht = _ptrFont[ _FONT_WIDTH_TABLE + c ];
	}
	
	return Font;
}

void Ssd1306ClearScreen( void )
{
	memset( DisplayRam , 0x00 , sizeof( DisplayRam ) );
}

void Ssd1306FillScreen( void )
{
	memset( DisplayRam , 0xFF , sizeof( DisplayRam ) );
}

void Ssd1306DrawPixel( uint8_t y , uint8_t x )
{
	 DisplayRam[ x + ( y / 8 ) * SSD1306_LCD_Width ] |=  ( 1 << ( y & 7 ) );
}

void Ssd1306ClearPixel( uint8_t y , uint8_t x )
{
	DisplayRam[ x + ( y / 8 ) * SSD1306_LCD_Width ] &=  ~( 1 << ( y & 7 ) );
}

uint16_t Ssd1306PutChar( char c , uint8_t y , uint8_t x )
{	
	Font_t Font = GetFont( c );	
	uint16_t uiLastWidht = 0;
	
	for ( uint16_t uiHeightInBytes = 0 ; uiHeightInBytes < Font.uiHeightInBytes ; uiHeightInBytes++ )
	{
		for ( uint16_t uiActualWidht = 0 ; uiActualWidht < Font.uiWidht ; uiActualWidht++ )
		{
			for ( uint8_t z = 0 ; z < 8 ; z++ )
			{
				if ( _ptrFont[Font.uiIndex + ( uiLastWidht + uiActualWidht ) ] & 1<<z )
				{
					Ssd1306DrawPixel( ( y + z ) + ( uiHeightInBytes * 128 ) , ( x + uiActualWidht ) + ( uiHeightInBytes * 128 ) );						
				}else
				{
					Ssd1306ClearPixel( ( y + z ) + ( uiHeightInBytes * 128 ) , ( x + uiActualWidht ) + ( uiHeightInBytes * 128 ) );
				}				
			}
		}
		uiLastWidht+=Font.uiWidht;
	}
	
	return Font.uiWidht;
}

void Ssd1306PutString( char *str, uint8_t y , uint8_t x )
{	
	uint16_t Space = 0;

  	while (*str)
  	{
		uint16_t FontWidht = Ssd1306PutChar( *str++ , y , x + Space ); 
 		Space += (FontWidht) + 10; // nächste Schreibposition anhand der größe vom Zeichen summieren.
	 }
}

void Ssd1306SendRam( void )
{
	Ssd1306SendCmd( SSD1306_CMD_COLUMN_LOW_ADDR  | 0x0 );
	Ssd1306SendCmd( SSD1306_CMD_COLUMN_HIGH_ADDR | 0x0 );
	Ssd1306SendCmd( SSD1306_CMD_SET_START_LINE	 | 0x0 );

	cli();
	
	i2c_start( SSD1306_ADDR + I2C_WRITE );
	
	i2c_write( SSD1306_MODE_DATA ); // Data is comming..
	
	for ( uint16_t ui = 0 ; ui < sizeof( DisplayRam ) ; ui++ )
	{
		i2c_write( DisplayRam[ui] );
	}
	i2c_stop(); 
	
	sei();
}
