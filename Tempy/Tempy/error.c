/* Generated by CodeDescriptor 1.5.0.0907 */
/*
* Project Name      -> Error Handling
* Version           -> 1.0.0.0528
* Author            -> Hm @ Workstadion.: QP-01-02
* Build Date        -> 28.05.2018 06:38:46
* Description       -> Description
*
*	Aufbau des Fehlerspeichers.:
*
*	*->buff[ID][NUM] -> ID = Fehler Typ (I2C , USART , LCD usw.).
*						NUM = Fehler die Aufgetreten sind ( Anzahl der zu speichernden -
*							  Fehler hängt von "ERROR_BUFFER_ID_SIZE" ab.
*
*
*	Bevor die Funktionen genutzt werden, muss einmal "errorInit( FEHLERSTRUKTUR )" aufgerufen werden!
*
*	Fehler werden mithilfe der Funktion "errorWrite( FEHLERSTRUKTUR , FEHLER_ID , ERROR ) in den Fehlerspeicher eingetragen.
*
*	Die Funktion "*errorGetExist( FEHLERSTRUKTUR )" liefert einen String mit den im Fehlerspeicher vorhandenen Fehlern & dazugehörigen ID´s
*
*/


#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <string.h>

#include "error.h"

error_t err;

static uint8_t checkBuff( error_t *strc )
{	
	uint8_t index = 0;
	
	if( strc->len >= ERROR_BUFFER_ID_SIZE * ERROR_BUFFER_NUM_SIZE )
	{
		return 1; // Kompletter Fehlerspeicher ist voll	
	}
	
	if( strc->id >= ERROR_BUFFER_ID_SIZE )
	{
		return 2; // ID nicht vorgesehen!
	}

	if( strc->err[strc->id][0] >= ERROR_BUFFER_NUM_SIZE )
	{
		/*
		*	Sollte ein ID "Fehlerspeicher" voll sein,
		*	so wird 30 + die ID des vollen "Fehlerspeichers"
		*	zurückgegeben
		*/
		return ( (3 * 10) + index );
	}

	if( strc->lastErr == 0 )
	{
		return 4; // Fehlermeldungen dürfen nicht <= 0 sein!
	}

	return 0; // Alles inordnung!
}

uint8_t errorInit( error_t *strc )
{
	uint8_t index;
	uint8_t cnt;
		
	for( index = 0 ; index < ERROR_BUFFER_ID_SIZE ; index++ )
	{
		strc->buff[index][ERROR_ID] = 0xFF;
		strc->err[index][0] = 0;
		for( cnt = 0 ; cnt < ERROR_BUFFER_NUM_SIZE ; cnt++ )
		{
			strc->buff[index][ERROR_BEGIN + cnt] = 0;
		}
	}
	
	return 0;
}

uint8_t errorWrite( error_t *strc , uint8_t id , uint8_t err )
{
	strc->id = id;
	strc->lastErr = err;
	
	uint8_t retCode = checkBuff( strc );
	
	if( retCode > 0 )
	{
		return retCode;
	}
	
	strc->buff[id][ERROR_ID] = id;
	
	if( strc->err[id][0] < ERROR_BUFFER_NUM_SIZE )
	{
		strc->len++;
		strc->buff[id][ERROR_BEGIN + strc->err[id][0]++] = err;
	}
	
	return 0;
}

uint8_t errorWriteCircular( error_t *strc , uint8_t id , uint8_t err )
{
	strc->id = id;
	strc->lastErr = err;
	
	uint8_t retCode = checkBuff( strc );
	
	if( retCode == 2 || retCode == 4 )
	{
		return retCode;
	}
	
	strc->buff[id][ERROR_ID] = id;
	
	if( strc->err[id][0] >= ERROR_BUFFER_NUM_SIZE )
	{
		strc->err[id][0] = 0;
	}
	
	if( strc->err[id][0] < ERROR_BUFFER_NUM_SIZE )
	{
		strc->len++;
		strc->buff[id][ERROR_BEGIN + strc->err[id][0]++] = err;
	}
	
	return 0;
}

void errorClear( error_t *strc , uint8_t id )
{
	memset( strc->buff[id] , '\0' , ERROR_BUFFER_NUM_SIZE );
	
	/*
	*	Anzahl der Fehler auf 0 setzen
	*/
	strc->err[id][ERROR_ID] = 0xFF;
	
	/*
	*	Anzahl des freien Speicherplatze(s) wieder korrigieren
	*/
	strc->len -= ERROR_BUFFER_NUM_SIZE;
	
	/*
	*	Letzte bekannte ID löschen
	*/
	strc->id = 0;
	
	/*
	*	Letzten bekannten Fehler löschen
	*/
	strc->lastErr = 0;
}

uint8_t errorFreeSize( error_t *strc , uint8_t id )
{
	return ( ERROR_BUFFER_NUM_SIZE - strc->err[id][0] );
}

char *errorGetExist( error_t *strc )
{
	uint8_t id = 0;
	uint8_t err = 0;
	
	char tmp[2] = "";
	
	static char out[ (ERROR_BUFFER_ID_SIZE * ( ( ERROR_BUFFER_NUM_SIZE + 3 ) * 2) ) ] = "";
	
	/*
	*	Die Ausgabe muss bei jedem Aufruf der Funktion gelöscht werden
	*/
	memset( out , 0 , sizeof(out) / sizeof(out[0]));
	strcpy( out , "Ok" );
	
	for( id = 0 ; id < ERROR_BUFFER_ID_SIZE ; id++ )
	{
		err = 0;
		if( strc->buff[id][ERROR_ID] != 0xFF )
		{
			itoa	( id 	, tmp , 10 	);
			strcat	( out	, "<"		);
			strcat	( out 	, tmp 		);
			strcat	( out 	, "#" 		);
			
			
			while( err < strc->err[id][0] )
			{
				itoa	( strc->buff[id][ERROR_BEGIN + err++] , tmp , 10 );
				strcat	( out , tmp );
				
				if( ( strc->buff[id][ ERROR_BEGIN + ( err ) ] != '\0' ) && err < strc->err[id][0] )
				{
					strcat( out , "," );
				}							
			}
			
			strcat( out , ">" );
		}
	}

	return out;
}

char *errorGetById( error_t * strc , uint8_t id )
{
	uint8_t err = 0;
	
	char tmp[2] = "";
	
	static char out[ ( ERROR_BUFFER_NUM_SIZE * 2 ) + 3 ] = "";
	memset( out , 0 , sizeof( out ) / sizeof( out[0] ) );
	strcpy( out , "Ok" );

	if( strc->buff[id][ERROR_ID] != 0xFF )
	{
		itoa	( id 	, tmp , 10 	);
		strcpy	( out	, "<"		);
		strcat	( out 	, tmp 		);
		strcat	( out 	, "#" 		);
			
		while( err < strc->err[id][0] )
		{
			itoa	( strc->buff[id][ERROR_BEGIN + err++] , tmp , 10 );
			strcat	( out , tmp );
			
			if( ( strc->buff[id][ ERROR_BEGIN + ( err ) ] != '\0' ) && err < strc->err[id][0] )
			{
				strcat( out , "," );
			}							
		}
		strcat( out , ">" );
	}
	
	return out;
}



//int main ()
//{	
//	/*
//	*	Fehlerstruktur erstellen
//	*/
//	error_t err;
//	/*
//	*	Fehlerstruktur mit default Werten laden
//	*/
//	errorInit( &err );
//	/*
//	*	Einen Fehler in die Struktur eintragen
//	*/
//	errorWrite( &err , _ERROR_I2C_ , ERROR_I2C_NO_ACK );
//	errorWrite( &err , _ERROR_I2C_ , 7 );
//	errorWrite( &err , _ERROR_I2C_ , 9 );
//
//	errorWrite( &err , 5 , ERROR_I2C_NO_ACK );
//	errorWrite( &err , 5 , 7 );
//	errorWrite( &err , 5 , 9 );	
//	/*
//	*	Alle vorhandenen Fehler ausgeben
//	*/
//	printf( "%s" , errorGetExist( &err ) );
//	
//
//    return 0;
//}

